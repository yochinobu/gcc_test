# GccTemplate(旧gcc_test)

## 概要  
rx用gccコンパイラgnurxによる開発用プロジェクトテンプレート。  
cs+から移植したプロジェクト(cc-rx)とは微妙に互換性がない。  
~~rx用gccコンパイラ gnurxによる開発のための実験用プロジェクトリポジトリ。~~  
~~コンパイラのツールチェインから既存ライブラリとの競合解決など~~  

## gccを使うメリット  

* c++11が使える！！  
    * コレに尽きる
    * STLが使える
        * これで連結リスト作成に2，3時間もかけなくて済むよ！
    * std::functionも使える！
        * 割り込み周りがすっきりするといいな
    * テンプレートも使える！
    * enumクラスも使えるよ！

## 導入

1. GNURX Toolchainのインストール  
    1. [GNUTools](https://gcc-renesas.com/ja/rx-download-toolchains/)からGNURX Toolchainの最新版(2018/9の時点で4.8.4.201801)をダウンロード  
    この際アカウント作成を求められるので言われた通りに作る(企業名とかは適当)  
    1. インストーラを起動。アクティベーションコードなるものを要求されるので[GnuToolsのダッシュボード(要ログイン)](https://gcc-renesas.com/wp-admin/index.php)からコピペする  
1. e2studioにツールチェインを追加  
    1. `ウィンドウ -> 設定`で設定ウィンドウを開く
    1. `C/C++ -> Renesas -> Renesas ツールチェーン管理`を開く
    1. ツールチェーン・タイプに`GCC for Renesas RX`があればその中からダウンロードしたバージョンにチェックを入れ`OK`。なければ`スキャン...`をクリック
    ![1](https://user-images.githubusercontent.com/43224034/54066213-cecf3580-426f-11e9-92d5-63c5914a5f98.png)
1. リポジトリをクローン  
1. __stdio.hの変更__  
シリアル周りでエラーが出た場合、
    1. `Library/UART/UART.h`の`putc()` or `getc()`にカーソルを合わせてF3キー  
    1. `stdio.h`に飛ぶので、putcとgetcのマクロを定義している2行をコメントアウト  
    1. 保存してビルド

## 既存のCC-RXプロジェクトへのマージ  

### 概要
CC-RXで作成していたプロジェクトを無理矢理GCCに移行する  
手順を一文で説明すると「リモートを追加してチェリーピックしたものをマージする」

### 前提
* GCCがツールチェインされている  
* コミットされていない変更がない  
  e2studioを開いているとマージ作業中にちょくちょく  
設定ファイルが変更されるので閉じておくのが吉  
万が一の時のためにプッシュしておいた方がいいかも

### 手順

1. CC-RXプロジェクトのリポジトリにリモートリポジトリを追加  
SourceTreeの`リモートの追加`からGccTemplateを「リモート名:gcc」で追加してフェッチ
1. 最新のコミットにチェックアウト  
(18/10/29次点ではmasterが最新のコミットなので)gcc/masterにチェックアウト。ブランチ名で「master」はおそらく使えないので「gcc_master」とかにする  
チェックアウトした時点でリモートは用済みなので削除しておく
1. コミットをまとめる  
    1. ターミナルを起動し、`git rebase -i [gcc_masterのinitial commitのハッシュ]`  
この場合のハッシュは、`git rebase -i a324b6c8587a47098974e6b6d81cfea7f9d7812c`でよいはず  
(もしrebaseができない場合、ターミナルを再起動してみるとよい)
    1. git rebaseが起動し、vimで編集が可能  
各行頭の`pick`を`fixup`に変更(`:%s/pick/fixup/`)  
1行目のみ`pick`を`reword`に変更し、保存して終了  
    1. コミットメッセージ編集が表示されるので`[add] GccTemplateの変更を追加`とでもしておく
    1. コミットメッセージを保存・終了すればリベースが始まり、コミットがまとめられ表示がすっきりするはず
1. マージ用ブランチを作成  
CC-RXプロジェクト側の適当なブランチにチェックアウトし、そこからgccとのマージ用ブランチ「gcc_merge」を作成し、チェックアウト
1. initial commitへハードリセット  
CC-RXプロジェクトのinitial commit(Templateリポジトリを使用していたら[693a0ac])へハードリセット  
変なものが沸いたら削除なり破棄なりしてよし
1. チェリーピック  
gcc_masterの最新コミット(さっきリベースしたヤツ)を右クリックし、チェリーピックを選択  
gcc_margeへコミットがコピーされる  
チェリーピックが完了すればgcc_masterは用済みなのでブランチを削除しておく
1. gcc_margeへマージ  
    1. gccをマージしたいブランチを、まずはgcc_margeへマージ  
    1. いくつかの設定ファイルが競合するため、競合ファイルを全て選択し、右クリックの`競合を解決`から`自分の変更で競合を解決`を選択し、gcc_marge側の変更を残す
    1. 競合が解決したら、そのままマージコミットとしてコミット
    1. ここからはe2studioも駆使して各種変更へ対応  
それぞれのライブラリにおけるcc-rxとgccの差はREADMEwikiの各ページを参照(書いてあればだがな！！)  
1. cc-rxのメインブランチへマージ  
ビルドに成功し、正常に動作することが確認できたら元のプロジェクトのmasterブランチやdevelopブランチへマージし、gcc_margeブランチを削除して終了  

### マージの際の注意点
* 一部のライブラリはcc-rxとgccとでインターフェースが異なるものがあるため、使用側を書き換える必要アリ  
    * Canは壮絶な仕様変更があるため、特殊なパケットで通信している場合はなかなか困難
